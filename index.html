<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guwahati Floods Investigation</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #3b82f6;
            --accent-glow: rgba(59, 130, 246, 0.3);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.05);
            z-index: 1000;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.1s ease-out;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        /* Hero Section */
        #hero {
            background: 
                linear-gradient(135deg, rgba(10, 10, 10, 0.8), rgba(20, 40, 60, 0.9)),
                url("https://drive.google.com/thumbnail?id=1HS6aN7jF0xfZEH8SlMMxCqs7wleeNo5g&sz=w2000");
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        .hero-content {
            text-align: center;
        }

        .hero-title {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 700;
            margin-bottom: 1.5rem;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ffffff, #60a5fa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-size: clamp(1.1rem, 2vw, 1.4rem);
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto 3rem;
            line-height: 1.8;
        }

        .scroll-hint {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: var(--text-secondary);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Section Titles */
        .section-title {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 600;
            margin-bottom: 1.2rem;
            text-align: center;
            word-break: break-word;
  max-width: 90vw;
  overflow-wrap: anywhere;
        }

        .section-subtitle {
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        /* SAR Section */
        #sar-section {
            background-image:
                linear-gradient(-45deg, rgba(96, 96, 96, 0.2), rgba(20, 40, 40, 0.8)),
                url("https://earthdata.nasa.gov/s3fs-public/styles/hds_large/public/2023-01/sentinel-1_sar_turkey.jpg");
            background-size: cover;
            background-position: center;
            min-height: 100vh;
            padding: 6rem 2rem 4rem 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        .sar-info-container {
            max-width: 1700px;
            width: 95%;
            margin: 0 auto;
            padding: 0 3rem;
        }

        .intro-text {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto 3rem auto;
            text-align: center;
            background: none;
            box-shadow: none;
            padding: 0 3rem;
            position: relative;
            z-index: 10;
        }

        .intro-text p {
            font-size: 1.3rem;
            color: #ffffff;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            line-height: 1.8;
            text-align: center;
        }

        .intro-text h3 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .info-box {
            background: #f7f7f2;
            color: #333;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transition: all 0.4s ease;
            min-height: 250px;
            opacity: 0;
            transform: scale(0.8);
        }

        .info-box img {
            width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 1rem;
        }

        .info-layout {
            display: flex;
            gap: 2rem;
            margin-top: 2rem;
            align-items: stretch;
        }

        .box-main {
            flex: 0 0 45%;
            transform: translateX(-100px) scale(0.8);
            min-height: 520px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .box-main.visible {
            transform: translateX(0) scale(1);
        }

        .info-grid-small {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .box-right {
            transform: translateX(100px) scale(0.8);
        }

        .info-box h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #1e3c72;
        }

        .info-box p {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #555;
        }

        .info-box.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
        }

        .info-box:hover {
            background: #ed7777;
            transform: translateX(0) scale(1.05);
            box-shadow: 0 15px 40px rgba(237, 119, 119, 0.4);
        }

        .info-box:hover h3,
        .info-box:hover p {
            color: white;
        }

        /* Game Section with Scroll Lock */
        #game-section {
            background: var(--bg-secondary);
        }

        #scene-container {
            height: 500vh;
            position: relative;
        }

        .sticky-container {
            position: sticky;
            top: 0;
            height: 100vh;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #game-scene,
        #soil-scene {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #game-scene {
            z-index: 2;
            will-change: opacity;
        }

        #soil-scene {
            z-index: 1;
            opacity: 0;
            will-change: transform, opacity;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            border-radius: 12px;
            overflow: hidden;
            cursor: crosshair;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            --zoom-target-x: 70%;
            --zoom-target-y: 35%;
            --zoom-target-width: 15%;
            --zoom-target-height: 20%;
        }

        .sar-image {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: opacity 0.3s ease;
        }

        .sar-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .sar-before {
            opacity: 0;
        }

        .game-container:hover .sar-before {
            opacity: 1;
        }

        .button-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .flood-button, .flood-button-small, .flood-button-big {
            position: absolute;
            background: transparent;
            border: 2px dashed rgba(255, 255, 255, 0);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .flood-button { width: 80px; height: 80px; }
        .flood-button-small { width: 50px; height: 50px; }
        .flood-button-big { width: 120px; height: 120px; }

        .flood-button:hover, .flood-button-small:hover, .flood-button-big:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            transform: scale(1.1);
        }

        .flood-button.clicked, .flood-button-small.clicked, .flood-button-big.clicked {
            background: rgba(34, 197, 94, 0.3);
            border-color: #22c55e;
            pointer-events: none;
        }

        .flood-button.revealed, .flood-button-small.revealed, .flood-button-big.revealed {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        .intensity-indicator {
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .intensity-cold { color: #60a5fa; }
        .intensity-warm { color: #fb923c; }
        .intensity-hot { color: #ef4444; }

        .game-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 0.875rem 2rem;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid var(--accent);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--accent-glow);
        }

        .btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: #60a5fa;
        }

        .game-status {
            text-align: center;
            color: var(--text-secondary);
            min-height: 2rem;
        }

        .soil-map-target {
            position: absolute;
            left: var(--zoom-target-x);
            top: var(--zoom-target-y);
            width: var(--zoom-target-width);
            height: var(--zoom-target-height);
            pointer-events: none;
        }

        .soil-layout {
            width: 90vw;
            max-width: 1200px;
            min-height: 80vh;
            height: auto;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            padding-bottom: 2rem;
        }

        .soil-image-container {
            position: absolute;
            width: 58%;
            max-height: 100%;
            height: 50vh;
            top: 360px;  
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .soil-image-large {
            width: 100%;
            height: 100%;
            background: url('https://drive.google.com/thumbnail?id=1_0jSDsUAKvoSpXGJAhnQGUkATNbm-_n3') no-repeat center center/cover;
        }

        .soil-text-content,
        .soil-detail-boxes-container {
            position: relative;
            flex: 1;
            min-width: 300px;

        }

        .soil-text-content {
            background: rgba(20, 20, 30, 0.5);
            padding: 1.5rem;
            border-radius: 15px;
            will-change: opacity;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: visible;
        }

        .soil-text-content h2 {
            margin-bottom: 1rem;
            font-size: 2rem;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .soil-text-content p {
            line-height: 1.7;
            margin-bottom: 1.5rem;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-box {
            width: 25px;
            height: 25px;
            border-radius: 5px;
            border: 1px solid #fff3;
        }

        .soil-detail-boxes-container {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            gap: 1.2rem;
            padding: 1rem 0;
        }

        .detail-box {
            background-color: #f7f7f2;
            color: #333;
            padding: 1.5rem 1.2rem;
            min-height: 120px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(-150px) scale(0.8);
            transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.6s ease, background-color 0.3s ease, color 0.3s ease;
            cursor: pointer;
            text-align: left;
            will-change: transform, opacity;
            overflow: hidden;
            word-wrap: break-word;
        }

        .detail-box h3 {
            margin-bottom: 0.8rem;
            font-size: 1.3rem;
            font-weight: bold;
            line-height: 1.3;
        }

        .detail-box p {
            font-size: 0.95rem;
            line-height: 1.6;
            overflow-wrap: break-word;
        }

        .detail-box:hover {
            background-color: #ed7777;
            color: white;
        }

        #scroll-lock-message {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #scroll-lock-message.show {
            opacity: 1;
        }

        /* Impact Section */
        #impact-section {
            background: var(--bg-secondary);
        }

        #map {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1;
        }

        .info-bubble {
            display: none;
            position: absolute;
            background: #fff;
            color: #111;
            padding: 0;
            border-radius: 10px;
            width: 280px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            overflow: hidden;
        }

        .info-bubble.show {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .info-bubble h3 {
            background: #3b82f6;
            color: white;
            padding: 0.75rem 1rem;
            margin: 0;
            font-size: 1.1rem;
        }

        .info-bubble-content {
            padding: 1rem;
        }

        .info-bubble p {
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 0.5rem;
        }

        .info-bubble img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            margin-top: 0.5rem;
            border-radius: 5px;
        }

        /* Roadmap Section */
        #roadmap-section {
  min-height: 250vh;
  background-image: url('https://raw.githubusercontent.com/highfreakquency/sar-flood-analysis-assam/main/images_website/Tista-River-tributary-Brahmaputra-India-Siwalik-Hills-1270583217.jpg');
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
  justify-content: flex-start;
  padding-top: 5vh;
}



        #roadmap-section .sticky-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .roadmap-container {
            width: 100%;
            max-width: 800px;
            height: 80vh;
            position: relative;
        }

        .strategy-point {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            padding: 1.2rem;
            border-radius: 10px;
            width: 280px;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.4s ease, transform 0.4s ease;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .strategy-point.show {
            opacity: 1;
            transform: scale(1);
        }

        .strategy-point h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #667eea;
        }

        .strategy-point p {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Outro Section */
        #outro-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            text-align: center;
        }

        .outro-content h2 {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            margin-bottom: 2rem;
        }

        .outro-content p {
            font-size: 1.3rem;
            max-width: 600px;
            margin: 0 auto 2rem;
            color: rgba(255, 255, 255, 0.95);
            line-height: 1.8;
        }

        .outro-content a {
            color: #ffffff;
            text-decoration: underline;
            font-weight: 600;
        }

        .outro-content a:hover {
            color: #fff3;
        }

        .github-link {
            display: inline-block;
            margin-top: 2rem;
            padding: 1rem 2.5rem;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50px;
            color: white;
            font-size: 1.1rem;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .github-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .info-layout {
                flex-direction: column;
            }
            
            .box-main {
                flex: 1;
            }

            .info-grid-small {
                grid-template-columns: 1fr;
            }

            .soil-layout {
                flex-direction: column;
            }

            .soil-image-container,
            .soil-text-content,
            .soil-detail-boxes-container {
                position: relative;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
    </div>

    <!-- Slide 1: Landing Page (from new6.html) -->
    <section id="hero">
        <div class="hero-content">
            <h1 class="hero-title">Guwahati Floods</h1>
            <p class="hero-subtitle">An environmental investigation into the annual floods that devastated Guwahati and neighbouring regions. As a government scientist, you'll analyze satellite imagery, soil composition, and regional impact to understand this natural disaster.</p>
            <div class="scroll-hint">Scroll to begin investigation â†“</div>
        </div>
    </section>

    <!-- Slide 2: "Where do we start?" (from guwahati-floods-story.html) -->
    <section id="sar-section">
        <h4 style="margin-bottom: 3rem; font-size: 4rem; font-weight: 700;">Where do we start?</h4>
        
        <div class="sar-info-container">
            <div class="intro-text">
                <p>So, you're tasked with analysing flood events. You might wonder where to start. While there's a huge amount of satellite data available, including optical imagery, it's often limited by clouds or night-time conditions. The most reliable tool you can rely on is SAR (Synthetic Aperture Radar) data, which can see through clouds and capture terrain changes accurately. Let's dive in and see how SAR helps us identify and understand flooded regions.</p>
            </div>

            <div class="info-layout">
                <div class="info-box box-main">
                    <h3>Sentinel-1</h3>
                    <p>The Sentinel-1 mission of the European Space Agency (ESA) comprises a constellation of two polar-orbiting satellites, operating day and night. The system of the two satellites provide C-band SAR data with different polarizations (VV and VH), allowing precise monitoring of water bodies, flooding, soil moisture, and land changes, while ensuring rapid product delivery. Its Interferometric Wide (IW) swath mode enables large-area coverage with high spatial resolution, making it ideal for mapping and change detection.</p>
                    <img src="https://sentiwiki.copernicus.eu/__attachments/1680406/Sentinel-1.jpg?inst-v=acd3fc36-9688-43d7-9443-6527ed080460" alt="Sentinel-1">
                </div>

                <div class="info-grid-small">
                    <div class="info-box box-right">
                        <h3>What is SAR?</h3>
                        <p>Synthetic Aperture Radar (SAR) is a type of active remote sensing technology that uses radar waves to capture high-resolution images of the Earth's surface. Unlike optical satellites, SAR can "see" through clouds, rain, and even operate at night, making it ideal for monitoring floods and other environmental events. It works by emitting microwave signals toward the ground and measuring the energy that bounces back, which helps distinguish between different types of surfaces like water, vegetation, and built-up areas.</p>
                    </div>

                    <div class="info-box box-right">
                        <h3>Backscatter Analysis</h3>
                        <p>We trained a CNN model which analyzes Sentinel-1 SAR images to detect flooded areas. It learns patterns in backscatter intensity and polarization to map inundated zones with high precision.</p>
                        <img src="https://drive.google.com/thumbnail?id=13VX8gNAWsIABAiySYQUz9dN_wbpUAB-J&sz=w1000" alt="Backscatter">
                    </div>

                    <div class="info-box box-right">
                        <h3>Pre-processing SAR images</h3>
                        <p>Before analysis, SAR data is pre-processed using ESA SNAP to improve accuracy. Steps include radiometric calibration, speckle filtering, and terrain correction to ensure the data accurately represented surface conditions for flood detection.</p>
                    </div>

                    <div class="info-box box-right">
                        <h3>Other Applications of SAR Data</h3>
                        <p>Beyond flood mapping, SAR data is widely used in monitoring deforestation, detecting oil spills, earthquake deformation, and even volcanic activity. This makes it a key tool in analysing physical drivers of any region.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Slide 3: Identify Flooded Regions with Stop-Scroll Mechanism (from new6.html + vishesh.html) -->
    <div id="scene-container">
        <div class="sticky-container">
            <div id="game-scene">
                <div class="container">
                    <h2 class="section-title">Step 1: Identify Flooded Regions</h2>
                    <p class="section-subtitle">Hover to compare before/after satellite imagery. Click on flooded areas.</p>
                    
                    <div class="game-wrapper">
                        <div class="intensity-indicator" id="intensity-indicator">Move cursor to search</div>
                        
                        <div class="game-container" id="game-container">
                            <div class="sar-image sar-after">
                                <img src="https://drive.google.com/thumbnail?id=1jMtug80UTnIgNRXv3FQJQmCNV1g0z33d&sz=w1000" alt="SAR After Flood">
                            </div>
                            <div class="sar-image sar-before">
                                <img src="https://drive.google.com/thumbnail?id=1CiUhl5jRnond3Xi_UJPzht1hViWA60lr&sz=w1000" alt="SAR Before Flood">
                            </div>
                            <div class="soil-map-target"></div>
                            <div class="button-overlay">
                                <button class="flood-button correct" style="left: 65%; top: 30%;" data-correct="true"></button>
                                <button class="flood-button correct" style="left: 45%; top: 35%;" data-correct="true"></button>
                                <button class="flood-button correct" style="left: 56%; top: 42%;" data-correct="true"></button>
                                <button class="flood-button-small correct" style="left: 85%; top: 55%;" data-correct="true"></button>
                                <button class="flood-button-small correct" style="left: 77%; top: 50%;" data-correct="true"></button>
                                <button class="flood-button-small correct" style="left: 43%; top: 70%;" data-correct="true"></button>
                                <button class="flood-button-big correct" style="left: 2%; top: 25%;" data-correct="true"></button>
                                <button class="flood-button-big correct" style="left: 90%; top: 45%;" data-correct="true"></button>
                                <button class="flood-button-big correct" style="left: 30%; top: 40%;" data-correct="true"></button>
                                <button class="flood-button" style="left: 80%; top: 20%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 50%; top: 60%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 74%; top: 70%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 10%; top: 75%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 85%; top: 85%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 20%; top: 10%;" data-correct="false"></button>
                                <button class="flood-button" style="left: 30%; top: 75%;" data-correct="false"></button>
                            </div>
                        </div>

                        <div class="game-controls">
                            <button class="btn" id="reveal-btn">Reveal All Locations</button>
                        </div>

                        <div class="game-status" id="game-status">Click on the darker regions to identify flood zones</div>
                    </div>
                </div>
            </div>

            <!-- Transition Scene (from vishesh.html) -->
            <div id="soil-scene">
                <div class="soil-layout">
                    <div class="soil-image-container">
                        <div class="soil-image-large"></div>
                    </div>
                    <div class="soil-text-content">
                        <h2>Step 2: Understanding the Landscape</h2>
                        <p>The land itself tells a story. Clayey soils retain water, exacerbating floods, while alluvial soils become easily waterlogged. Understanding soil composition is critical to flood risk assessment.</p>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="color-box" style="background:#2ecc40;"></div>
                                <span>Clayey Soil (High Risk)</span>
                            </div>
                            <div class="legend-item">
                                <div class="color-box" style="background:#0074d9;"></div>
                                <span>Alluvial Soil (Medium Risk)</span>
                            </div>
                            <div class="legend-item">
                                <div class="color-box" style="background:#ff4136;"></div>
                                <span>Vegetation Cover (Low Risk)</span>
                            </div>
                        </div>
                    </div>
                    <div class="soil-detail-boxes-container">
                        <div class="detail-box">
                            <h3>Image Composite</h3>
                            <p>This image was captured by the Sentinel-2 satellite. The visualization is a custom Short-Wave Infrared (SWIR) composite. It uses SWIR bands 11 and 12 to differentiate among rock types and Near-Infrared (NIR) band 8 to highlight vegetation.</p>
                        </div>
                        <div class="detail-box">
                            <h3>Cyan Tones: Alluvial Soil Flood Zone</h3>
                            <p>The cyan areas highlight alluvial soils. These are fertile, silty soils deposited by rivers over time. While excellent for agriculture, they can quickly become saturated during heavy rains or river swelling. This leads to severe waterlogging, turning these zones into dangerous areas for prolonged and deep flooding.</p>
                        </div>
                        <div class="detail-box">
                            <h3>Pale Green Tones: Clay Soil Flood Risk</h3>
                            <p>The pale green highlight areas with a high concentration of clay soil. Clay consists of very fine particles, which results in low permeability, meaning water cannot penetrate the ground easily. Therefore, even moderate rainfall can lead to flash floods and long periods of standing water.</p>
                        </div>
                        <div class="detail-box">
                            <h3>Red Tones: Vegetation Cover</h3>
                            <p>The red shade in this composite represent vegetation. These areas can range from dense forests to agricultural croplands. The intensity of the red color often indicates the health and density of the plant cover.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 4: Step 3 - Regional Impact Assessment (from new6.html) -->
    <section id="impact-section">
        <div class="container">
            <h2 class="section-title">Step 3: Regional Impact Assessment</h2>
            <p class="section-subtitle">Click on the markers to view detailed impact data</p>
            
            <div id="map"></div>
            <div class="info-bubble" id="info-bubble">
                <h3 id="location-name"></h3>
                <div class="info-bubble-content">
                    <p><strong>Soil Type:</strong> <span id="soil-level"></span></p>
                    <p><strong>Avg. Humidity:</strong> <span id="humidity"></span></p>
                    <p><strong>Cloud Cover:</strong> <span id="cloud-cover"></span></p>
                    <p><strong>Impact:</strong> <span id="impact"></span></p>
                    <img id="location-image" src="" alt="Location impact">
                </div>
            </div>
        </div>
    </section>

    <!-- Slide 5: Mitigation Strategies with Zigzag (from vishesh.html Step 4) -->
    <section id="roadmap-section">
        <div class="sticky-container">
            <div class="roadmap-container">
                <h2 class="section-title">Step 4: Mitigation Strategies</h2>
                <svg width="100%" height="100%" viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet" style="position: absolute;">
                    <path id="roadmap-path" d="M 400 50 L 200 200 L 600 350 L 200 500 L 600 650 L 400 750" stroke="#ffffff" stroke-width="3" fill="none" />
                    <circle id="roadmap-pointer" r="10" fill="#f093fb" stroke="#fff" stroke-width="3"></circle>
                </svg>
                <div class="strategy-point" data-progress="0.15" style="top: 10%; left: 50px;">
                    <h3>Effective Drainage</h3>
                    <p>Implement modern drainage systems to efficiently channel floodwater away from residential zones.</p>
                </div>
                <div class="strategy-point" data-progress="0.35" style="top: 30%; right: 50px;">
                    <h3>Smart Urban Planning</h3>
                    <p>Redesign urban areas with flood-resistant infrastructure and elevated structures.</p>
                </div>
                <div class="strategy-point" data-progress="0.55" style="top: 50%; left: 50px;">
                    <h3>Riverbank Reinforcement</h3>
                    <p>Strengthen riverbanks with bioengineering solutions to prevent overflow.</p>
                </div>
                <div class="strategy-point" data-progress="0.75" style="top: 70%; right: 50px;">
                    <h3>Risk Zone Management</h3>
                    <p>Map high-risk flood zones and implement strict construction regulations.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Outro Section -->
    <section id="outro-section">
        <div class="outro-content">
            <h2>Investigation Complete</h2>
            <p>This project is our submission for <a href="https://www.spaceappschallenge.org/nasa-space-apps-2024/challenges/through-the-radio-looking-glass/" target="_blank">NASA Space Apps Hackathon</a>. With love,<br>Team High Freak-quency</p>
            <a href="#" class="github-link">GitHub link</a>
        </div>
    </section>

    <div id="scroll-lock-message">Complete the game to continue</div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Disable body scrollbar when scroll is locked
        let scrollbarWidth = 0;
        
        function disableBodyScroll() {
            scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            document.body.style.overflow = 'hidden';
            document.body.style.paddingRight = scrollbarWidth + 'px';
        }
        
        function enableBodyScroll() {
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
        }

        // Progress bar
        const progressFill = document.getElementById('progress-fill');
        
        function updateProgress() {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            progressFill.style.width = scrollPercent + '%';
        }

        window.addEventListener('scroll', updateProgress);

        // SAR Info Boxes Scroll Animation
        const infoBoxes = document.querySelectorAll('.info-box');

        const boxObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry, index) => {
                if (entry.isIntersecting) {
                    setTimeout(() => {
                        entry.target.classList.add('visible');
                    }, index * 100);
                }
            });
        }, {
            threshold: 0.2,
            rootMargin: '0px 0px -100px 0px'
        });

        infoBoxes.forEach((box) => {
            boxObserver.observe(box);
        });

        const mainBox = document.querySelector('.box-main');
        if (mainBox) {
            boxObserver.observe(mainBox);
        }

        // Game Section with Scroll Lock and Transition
        document.addEventListener('DOMContentLoaded', () => {
            let gameWon = false;
            let initialTransform = '';
            let maxScrollBeforeGame = 0;
            let isAutoScrolling = false;
            let scrollLockActive = false;

            const sceneContainer = document.getElementById('scene-container');
            const gameScene = document.getElementById('game-scene');
            const soilScene = document.getElementById('soil-scene');
            const zoomTarget = gameScene.querySelector('.soil-map-target');
            const scrollLockMessage = document.getElementById('scroll-lock-message');

            const soilImageContainer = soilScene.querySelector('.soil-image-container');
            const soilTextContent = soilScene.querySelector('.soil-text-content');
            soilTextContent.style.opacity = 1; 
            const detailBoxes = soilScene.querySelectorAll('.detail-box');

            function calculateMaxScroll() {
                 // Lock only after whole game section is in view
            maxScrollBeforeGame = sceneContainer.offsetTop + sceneContainer.offsetHeight - window.innerHeight;
        }


            function smoothScrollTo(endY, duration) {
                isAutoScrolling = true;
                const startY = window.scrollY;
                const distance = endY - startY;
                let startTime = null;

                const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

                function animation(currentTime) {
                    if (startTime === null) startTime = currentTime;
                    const timeElapsed = currentTime - startTime;
                    const progress = Math.min(timeElapsed / duration, 1);
                    const easedProgress = easeInOutQuad(progress);

                    window.scrollTo(0, startY + distance * easedProgress);

                    if (timeElapsed < duration) {
                        requestAnimationFrame(animation);
                    } else {
                        isAutoScrolling = false;
                    }
                }
                requestAnimationFrame(animation);
            }

            function handleMasterWheel(event) {
                if (isAutoScrolling) {
                    event.preventDefault();
                    return;
                }

                if (!gameWon) {
                    const isAtLockPoint = window.scrollY >= maxScrollBeforeGame;
                    if (event.deltaY > 0 && isAtLockPoint) {
                        event.preventDefault();
                        scrollLockMessage.classList.add('show');
                        setTimeout(() => scrollLockMessage.classList.remove('show'), 2000);
                        if (!scrollLockActive) {
                            scrollLockActive = true;
                            disableBodyScroll();
                        }
                    }
                    return;
                }

                if (scrollLockActive) {
                    scrollLockActive = false;
                    enableBodyScroll();
                }

                const scrollPos = window.scrollY;
                const sceneTop = sceneContainer.offsetTop;
                const sceneHeight = sceneContainer.offsetHeight;
                const windowHeight = window.innerHeight;

                const autoScrollEndPos = sceneTop + (sceneHeight - windowHeight);

                if (event.deltaY > 0 && Math.abs(scrollPos - sceneTop) < 10) {
                    event.preventDefault();
                    smoothScrollTo(autoScrollEndPos, 1200);
                }

                if (event.deltaY < 0 && Math.abs(scrollPos - autoScrollEndPos) < 10) {
                    event.preventDefault();
                    smoothScrollTo(sceneTop, 1200);
                }
            }

            window.addEventListener('wheel', handleMasterWheel, { passive: false });
            
            // Also prevent scrollbar dragging when locked
            window.addEventListener('scroll', (e) => {
                if (!gameWon && window.scrollY >= maxScrollBeforeGame) {
                    window.scrollTo(0, maxScrollBeforeGame);
                }
            }, { passive: true });

            function calculateInitialTransforms() {
                const finalRect = soilScene.getBoundingClientRect();
                const targetRect = zoomTarget.getBoundingClientRect();
                if (targetRect.width === 0 || finalRect.width === 0) return;

                const scaleX = targetRect.width / finalRect.width;
                const scaleY = targetRect.height / finalRect.height;
                const translateX = (targetRect.left + targetRect.width / 2) - (finalRect.left + finalRect.width / 2);
                const translateY = (targetRect.top + targetRect.height / 2) - (finalRect.top + finalRect.height / 2);
                initialTransform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;

                soilScene.style.transform = initialTransform;
            }

            function handleSceneTransition() {
                const scrollPos = window.scrollY;
                const windowHeight = window.innerHeight;
                const animStart = sceneContainer.offsetTop;
                const animDuration = sceneContainer.offsetHeight - windowHeight;

                if (gameWon && scrollPos >= animStart) {
                    let progress = (scrollPos - animStart) / animDuration;
                    progress = Math.min(1, Math.max(0, progress));

                    const zoomEnd = 0.3;
                    if (progress <= zoomEnd) {
                        const zoomProgress = progress / zoomEnd;
                        gameScene.style.opacity = 1 - zoomProgress * 0.5;
                        soilScene.style.opacity = Math.min(1, zoomProgress * 5);

                        const currentTransform = initialTransform.match(/-?\d+\.?\d*/g);
                        if (currentTransform) {
                            const [startX, startY, startScaleX, startScaleY] = currentTransform.map(Number);
                            const currentTranslateX = startX * (1 - zoomProgress);
                            const currentTranslateY = startY * (1 - zoomProgress);
                            const currentScaleX = startScaleX + (1 - startScaleX) * zoomProgress;
                            const currentScaleY = startScaleY + (1 - startScaleY) * zoomProgress;
                            soilScene.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScaleX}, ${currentScaleY})`;
                        }
                    } else {
                        gameScene.style.opacity = 0;
                        soilScene.style.opacity = 1;
                        soilScene.style.transform = `translate(0px, 0px) scale(1, 1)`;
                    }

                    const transitionStart = 0.3;
                    const transitionEnd = 0.5;
                    if (progress > transitionStart) {
                        const transitionProgress = Math.min(1, (progress - transitionStart) / (transitionEnd - transitionStart));
                        soilTextContent.style.opacity = 1;

                        const targetTranslateX = -100
                        soilImageContainer.style.transform = `translateX(${targetTranslateX * transitionProgress}px)`;

                    } else {
                        soilTextContent.style.opacity = 1;
                        soilImageContainer.style.transform = 'translateX(0px)';
                    }

                    const boxesStart = 0.5;
                    if (progress > boxesStart) {
                        const boxesProgress = (progress - boxesStart) / (1 - boxesStart);
                        const thresholds = [0.1, 0.3, 0.5, 0.7];
                        detailBoxes.forEach((box, index) => {
                            if (boxesProgress >= thresholds[index]) {
                                box.style.opacity = 1;
                                box.style.transform = 'translateX(0) scale(1)';
                            } else {
                                box.style.opacity = 0;
                                box.style.transform = 'translateX(-150px) scale(0.8)';
                            }
                        });
                    } else {
                        detailBoxes.forEach(box => {
                            box.style.opacity = 0;
                            box.style.transform = 'translateX(-150px) scale(0.8)';
                        });
                    }

                } else if (scrollPos < animStart) {
                    gameScene.style.opacity = 1;
                    soilScene.style.opacity = 0;
                    if (initialTransform) {
                        soilScene.style.transform = initialTransform;
                    }
                }
            }

            // Game Logic
            const correctButtons = document.querySelectorAll('.flood-button.correct, .flood-button-small.correct, .flood-button-big.correct');
            const allButtons = document.querySelectorAll('.flood-button, .flood-button-small, .flood-button-big');
            const gameStatus = document.getElementById('game-status');
            const intensityIndicator = document.getElementById('intensity-indicator');
            const gameContainer = document.getElementById('game-container');
            const revealBtn = document.getElementById('reveal-btn');
            let clickedCorrect = 0;

            function getDistance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            function updateIntensity(mouseX, mouseY) {
                let minDistance = Infinity;
                correctButtons.forEach(button => {
                    if (!button.classList.contains('clicked')) {
                        const rect = button.getBoundingClientRect();
                        const buttonX = rect.left + rect.width / 2;
                        const buttonY = rect.top + rect.height / 2;
                        const distance = getDistance(mouseX, mouseY, buttonX, buttonY);
                        minDistance = Math.min(minDistance, distance);
                    }
                });

                if (minDistance < 80) {
                    intensityIndicator.textContent = 'Very Hot - Click here!';
                    intensityIndicator.className = 'intensity-indicator intensity-hot';
                } else if (minDistance < 180) {
                    intensityIndicator.textContent = 'Getting Warmer';
                    intensityIndicator.className = 'intensity-indicator intensity-warm';
                } else {
                    intensityIndicator.textContent = 'Cold - Keep searching';
                    intensityIndicator.className = 'intensity-indicator intensity-cold';
                }
            }

            gameContainer.addEventListener('mousemove', (e) => {
                if (!gameWon) {
                    updateIntensity(e.clientX, e.clientY);
                }
            });

            allButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.dataset.correct === 'true' && !button.classList.contains('clicked')) {
                        button.classList.add('clicked');
                        clickedCorrect++;
                        if (clickedCorrect === correctButtons.length) {
                            gameStatus.textContent = "Excellent! All flooded regions identified! Scroll to continue.";
                            intensityIndicator.textContent = 'All Regions Found!';
                            intensityIndicator.className = 'intensity-indicator';
                            gameWon = true;
                            if (scrollLockActive) {
                                scrollLockActive = false;
                                enableBodyScroll();
                            }
                        } else {
                            gameStatus.textContent = `Good! ${correctButtons.length - clickedCorrect} more region${correctButtons.length - clickedCorrect > 1 ? 's' : ''} to find.`;
                        }
                    } else if (button.dataset.correct !== 'true') {
                        gameStatus.textContent = "That area is stable. Look for darker regions.";
                    }
                });
            });

            revealBtn.addEventListener('click', () => {
                const isRevealed = revealBtn.classList.toggle('active');
                
                if (isRevealed) {
                    correctButtons.forEach(button => {
                        if (!button.classList.contains('clicked')) {
                            button.classList.add('revealed');
                        }
                    });
                    revealBtn.textContent = 'Hide Locations';
                    gameStatus.textContent = "All flooded regions revealed - click to continue playing";
                    intensityIndicator.textContent = 'All Locations Revealed';
                } else {
                    correctButtons.forEach(button => {
                        button.classList.remove('revealed');
                    });
                    revealBtn.textContent = 'Reveal All Locations';
                    if (clickedCorrect === correctButtons.length) {
                        gameStatus.textContent = "Excellent! All flooded regions identified!";
                    } else {
                        gameStatus.textContent = `${correctButtons.length - clickedCorrect} more region${correctButtons.length - clickedCorrect > 1 ? 's' : ''} to find.`;
                    }
                    intensityIndicator.textContent = 'Move cursor to search';
                }
            });

            function masterScrollHandler() {
                handleSceneTransition();
                handleRoadmap();
            }
            window.addEventListener('scroll', masterScrollHandler, { passive: true });

            setTimeout(() => {
                calculateMaxScroll();
                calculateInitialTransforms();
                masterScrollHandler();
            }, 100);

            window.addEventListener('resize', () => {
                calculateMaxScroll();
                calculateInitialTransforms();
            });
        });

        // Location Data & Map
        const locationData = {
            'Baghabari': { 
                soil: 'Alluvial',
                humidity: '84%', 
                cloud: 'Extensive', 
                impact: 'Severe residential flooding', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/Assam-flood-social-PTI-684291921.jpg',
                coords: [26.1844, 91.7458]
            },
            'Morigaon': { 
                soil: 'Alluvial',
                humidity: '85%', 
                cloud: 'Extensive', 
                impact: 'Widespread crop damage', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/1045184-assam-floods-6xxxxxxx-309318438.png',
                coords: [26.2528, 92.3433]
            },
            'Sonitpur': { 
                soil: 'Sandy loam', 
                humidity: '81%', 
                cloud: 'Significant', 
                impact: 'Riverbank erosion', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/Assam_floods-2154627984.JPG',
                coords: [26.6338, 92.8029]
            },
            'Pan Bazaar': { 
                soil: 'Urban Soil', 
                humidity: '83%', 
                cloud: 'Heavy during monsoon', 
                impact: 'Critical infrastructure offline', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/assam-flood-1655456591-715839949.jpg',
                coords: [26.1833, 91.7500]
            },
            'Dispur': { 
                soil: 'Alluvial',
                humidity: '84%', 
                cloud: 'Significant', 
                impact: 'Government centers affected', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/hqdefault-1839057067.jpg',
                coords: [26.1433, 91.7898]
            },
            'Changsari': { 
                soil: 'Clay and silty',
                humidity: '81%', 
                cloud: 'Significant', 
                impact: 'Agricultural & livestock loss', 
                img: 'https://raw.githubusercontent.com/highfreakquency/guwahati-flood-SAR-insights/main/images_website/1057217-assam-four-275219377.jpg',
                coords: [26.3667, 91.5167]
            }
        };

        // Initialize Leaflet Map after DOM loads
        setTimeout(() => {
            const map = L.map('map').setView([26.2, 91.8], 9);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);

            const bubble = document.getElementById('info-bubble');
            const mapSection = document.getElementById('impact-section');

            // Add markers
            Object.entries(locationData).forEach(([name, data]) => {
                const marker = L.marker(data.coords).addTo(map);
                
                marker.onclick = () => {
                    document.getElementById('location-name').textContent = name;
                    document.getElementById('humidity').textContent = data.humidity;
                    document.getElementById('precipitation').textContent = data.soil;
                    document.getElementById('impact').textContent = data.impact;
                    document.getElementById('location-image').src = data.img;

                    const markerRect = e.target._icon.getBoundingClientRect();
                    const mapRect = mapSection.getBoundingClientRect();
                    
                    bubble.style.position = 'absolute';
                    bubble.style.left = `${markerRect.left - mapRect.left + markerRect.width / 2 - 140}px`;
                    bubble.style.top = `${markerRect.top - mapRect.top - 280}px`;
                    bubble.classList.add('show');
                }
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.leaflet-marker-icon') && !e.target.closest('.info-bubble')) {
                    bubble.classList.remove('show');
                }
            });
        500});

        // Roadmap animation
        const roadmapSlide = document.getElementById('roadmap-section');
        const path = document.getElementById('roadmap-path');
        const pointer = document.getElementById('roadmap-pointer');
        const points = document.querySelectorAll('.strategy-point');
        const pathLength = path ? path.getTotalLength() : 0;

        function handleRoadmap() {
            if (!path) return;
            const scrollPos = window.scrollY;
            const windowHeight = window.innerHeight;
            const scrollStart = roadmapSlide.offsetTop;
            const scrollEnd = scrollStart + roadmapSlide.offsetHeight - windowHeight;

            if (scrollPos >= scrollStart && scrollPos <= scrollEnd) {
                const slideProgress = (scrollPos - scrollStart) / (scrollEnd - scrollStart);

                path.style.strokeDasharray = pathLength;
                path.style.strokeDashoffset = pathLength * (1 - slideProgress);

                const pointOnLine = path.getPointAtLength(pathLength * slideProgress);
                pointer.setAttribute('cx', pointOnLine.x);
                pointer.setAttribute('cy', pointOnLine.y);

                points.forEach(point => {
                    const targetProgress = parseFloat(point.dataset.progress);
                    point.classList.toggle('show', slideProgress >= targetProgress);
                });
            }
        }
    </script>
</body>
</html>

